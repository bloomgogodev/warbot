#!/usr/bin/env python
# -*- coding: utf-8 -*- 

"""
WarBotTwitter
=============

This module interacts with WarBotAPI to deliver messages to Twitter.

"""

__author__      = "Miguel √Ångel Fern√°ndez Guti√©rrez (@mianfg)"
__copyright__   = "Copyright 2019, Bloomgogo"
__credits__     = ["Miguel √Ångel Fern√°ndez Guti√©rrez"]
__license__     = "GPL"
__version__     = "1.0"
__mantainer__   = "Miguel √Ångel Fern√°ndez Guti√©rrez"
__email__       = "mianfg@bloomgogo.com"
__status__      = "Production"



from warbot import WarBot
from api import WarBotAPI
from database import WarBotDB
from imagehandler import WarBotImageHandler
from vars import log

import time, random, os
from datetime import datetime, timedelta


class WarBotTwitter:
    """
    Class used to deliver messages to and receive messages from Twitter

    ...

    Attributes
    ----------
    api : WarBotAPI
        Interact with Twitter API
    bot : WarBot
        Get and send information to bot
    sleep_time : int
        Sleep time for Twitter API
    sleep_time_optin : int
        Sleep time for Twitter API if opt-in activated
    imgh : WarBotImageHandler
        Generates images
    
    Methods
    -------

    """

    def __init__(self, consumer_key, consumer_secret, \
        access_token, access_token_secret, twitter_sleep_time, \
        database_route, database_filename, \
        ih_images_route, ih_resources_route, ih_store_route):
        """
        Parameters
        ----------
        consumer_key : str
            Twitter app consumer key
        consumer_secret : str
            Twitter app consumer secret
        access_token : str
            Twitter app access token
        access_token_secret : str
            Twitter app access token secret
        twitter_sleep_time : int
            Update time, in seconds
        database_route : str
            Folder route to database file
        database_filename : str
            Filename of JSON database for WarBotDB.
                To avoid bugs, must be absolute path
        ih_images_route : str
            Folder route to images for WarBotImageHandler.
                To avoid bugs, must be absolute path
        ih_resources_route : str
            Folder route to templates for WarBotImageHandler.
                To avoid bugs, must be absolute path
        ih_store_route : str
            Folder route to store images generated by WarBotImageHandler.
                To avoid bugs, must be absolute path
        """

        self.api = WarBotAPI(consumer_key, consumer_secret, \
            access_token, access_token_secret, \
            database_route, database_filename, ih_images_route)
        self.bot = WarBot(database_route, database_filename)
        self.sleep_time = twitter_sleep_time
        self.sleep_time_optin = twitter_sleep_time * 4
        self.imgh = WarBotImageHandler(ih_images_route, ih_resources_route, \
            ih_store_route)


    def battle(self):
        """Execute battle, as in /forcebattle

        Executes battle, randomly
        """

        winner, defeated = self.bot.battle()

        self.bot.add_battle_queue(winner, defeated)

        if self.bot.get_stop_frequency():
            self.bot.set_stop_next_battle(True)
        else:
            self.bot.set_stop_next_battle(False)

            newnextbattle = self.bot.get_next_battle()
            h, m = self.bot.get_battle_frequency()
            newnextbattle += timedelta(hours=h, minutes=m)

            self.bot.set_next_battle(newnextbattle)

     
    def optin(self):
        """Executes opt-in functionality
        """

        try:
            mentions = self.api.get_mentions()
            
            for mention in mentions:
                username = mention.user.screen_name
                self.bot.add_candidate(username)

            log.send_message("[TWITTER] Mentions caught")
        except Exception as e:
            log.send_message("[TWITTER] Mentions could not be caught -> " + str(e))


    def send_battle(self, winner, defeated, alivelist):
        """Send battle message to Twitter

        Sends battle message, including images

        Parameters
        ----------
        winner : str
            Winner user's username
        defeated : str
            Defeated user's username
        alivelist : list<str>
            Alive user's list
        """

        # generate filenames
        img1 = winner + "_profilepic.png"
        img1_route = self.api.download_profilepic(winner, img1)
        img2 = defeated + "_profilepic.png"
        img2_route = self.api.download_profilepic(defeated, img2)
        out = "battle-"+winner+"_"+defeated+".png"
        out_route = self.imgh.generate_battle(img1, img2, out)

        # generate text
        left = len(self.bot.get_alive_users())
        if left == 1:
            left_text = "¬°@{} ha ganado la guerra! üèÜ".format(winner)
        else:
            left_text = "Quedan {} usuarios".format(left)
        if left == 2:
            left_text += ". ¬øQui√©n ganar√° la guerra? ü§î ¬°Hagan sus apuestas!"
        images = [out_route]

        # if wants to display list
        if alivelist and left > 1:
            out2 = "aliveusers_" + str(random.randint(1000, 9999)) + ".png"
            out2_route = self.imgh.generate_alive(self.bot.get_users_extended(), out2)
            images.append(out2_route)
        if left == 1:
            out2 = "winneruser_" + str(random.randint(1000, 9999)) + ".png"
            out2_route = self.imgh.generate_winner(img1, out2)
            images.append(out2_route)
        
        # post tweet
        try:
            self.api.post_tweet("@{} ha matado a @{}. ".format(winner, defeated) \
                + left_text, images)
            log.send_message("[TWITTER] Tweet posted: " + winner + \
                " killed " + defeated)
            self.bot.add_message_queue("üõéÔ∏è Publicado tweet: " \
                + "*{}* ha matado a *{}*.".format(winner, defeated))
        except Exception as e:
            log.send_message("[TWITTER] Tweet COULD NOT be posted: " + \
                winner + " killed " + defeated + " -> " + str(e))
            self.bot.add_message_queue("‚ö†Ô∏è Tweet no pudo ser publicado: " \
                + "*{}* ha matado a *{}*.".format(winner, defeated))

        # remove images generated
        os.remove(img1_route)
        os.remove(img2_route)
        os.remove(out_route)
        if alivelist:
           os.remove(out2_route)
            

    def send_newuser(self, username):
        """Send new user message to Twitter

        Sends new user message, including image
        """

        # generate filenames
        img = username + "_profilepic.png"
        img_route = self.api.download_profilepic(username, img)
        out = "newuser-"+username+".png"
        out_route = self.imgh.generate_newuser(img, out)

        # post tweet
        try:
            self.api.post_tweet("¬°Nueva incorporaci√≥n! " + \
                "@{}, ¬°bienvenidx a la batalla!".format(username), [out_route])
            log.send_message("[TWITTER] Tweet posted: new user " + username)
            self.bot.add_message_queue("üõéÔ∏è Publicado tweet: nuevo usuario " \
                + "*{}*".format(username))
        except Exception as e:
            log.send_message("[TWITTER] Tweet COULD NOT be posted: new user " \
                + username + " -> " + str(e))
            self.bot.add_message_queue("‚ö†Ô∏è Tweet no pudo ser publicado: nuevo " \
                + "usuario *{}*".format(username))

        # remove images generated
        os.remove(img_route)
        os.remove(out_route)


    def main(self):
        """Main function

        Main function to be executed
        """

        while True:
            ann_queue = self.bot.get_announce_queue()
            ann_queue = list(dict.fromkeys(ann_queue)) # for security
            self.bot.wipe_announce_queue()

            battle_queue = self.bot.get_battle_queue()
            self.bot.wipe_battle_queue()

            for user in ann_queue:
                if self.bot.get_user_announce():
                    self.send_newuser(user)
            
            for battle in battle_queue:
                show_list = len(self.bot.get_alive_users()) \
                    < self.bot.show_threshold
                self.send_battle(battle['winner'], battle['defeated'], \
                    show_list)

            # battle scheduling
            if not self.bot.get_stop_next_battle():
                # run battle at specified time
                now = datetime.now().strftime("%d/%m/%Y %H:%M")
                
                sched = self.bot.get_next_battle().strftime("%d/%m/%Y %H:%M")
                
                if now == sched:
                    log.send_message("[TWITTER] Ran scheduled battle")
                    w, d = self.bot.battle()
                    if w == None or d == None:
                        self.bot.add_message_queue("‚ö†Ô∏è No se pudo producir la " \
                        + "batalla programada. Parando programaciones.")
                        self.bot.set_stop_frequency(True)
                    else:
                        self.bot.add_message_queue("üõéÔ∏è Se ha producido una " \
                            + "batalla programada: *{}* ".format(w) \
                            + "ha matado a *{}*.".format(d))
                    self.bot.set_stop_next_battle(True)

                    # if the frequency is set, we set next schedule
                    if not self.bot.get_stop_frequency():
                        log.send_message("[TWITTER] New schedule set due " \
                            + "to schedule frequency")
                        # calculate next battle
                        h, m = self.bot.get_battle_frequency()
                        date = self.bot.get_next_battle() + \
                            timedelta(hours=int(h), minutes=int(m))
                        self.bot.set_next_battle(date.strftime("%d/%m/%Y %H:%M"))
                        self.bot.set_stop_next_battle(False)

            if self.bot.get_optin_running():
                self.optin()
                time.sleep(self.sleep_time_optin)
            else:
                time.sleep(self.sleep_time)